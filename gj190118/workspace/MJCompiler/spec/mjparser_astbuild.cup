package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   	boolean errorDetected;
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, PRINT, RETURN, BREAK, ELSE, CONST, IF, NEW, CLASS, READ, VOID, EXTENDS, FOR, CONTINUE, STATIC, NAMESPACE;
terminal PLUS, MINUS, MUL, DIV, MOV, EQUALTO, NOTEQUALTO, GREATER, GEQUAL, LESSER, LEQUAL, AND, OR, EQUAL, INC, DEC, SEMI, COLON, COMMA, DOT, LBRACE, RBRACE;
terminal LPAREN, RPAREN, LSQUARE, RSQUARE, LAMBDA, MAX;
terminal String IDENT;
terminal Integer NUMBER_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;
nonterminal DeclarationsList DeclarationsList;
nonterminal MethodDeclList MethodDeclList ;
nonterminal ConstDeclList ConstDeclList;
nonterminal VarDeclList VarDeclList;
nonterminal StaticInitializer StaticInitializer;
nonterminal ConstDeclarations ConstDeclarations;
nonterminal VarDeclarations VarDeclarations;
nonterminal VarDecl VarDecl;
nonterminal Brackets Brackets ;
nonterminal FormPars FormPars;
nonterminal FormalParamList FormalParamList;
nonterminal StatementList StatementList;
nonterminal StatementDecl StatementDecl;
nonterminal IfStmt IfStmt ;
nonterminal IfElseStmt IfElseStmt;
nonterminal DesignatorStmtList DesignatorStmtList;
nonterminal DesignatorStatementDecl DesignatorStatementDecl;
nonterminal DesignatorListNotEmpty DesignatorListNotEmpty;
nonterminal DesignatorListForStmt DesignatorListForStmt;
nonterminal DesignatorStatementList DesignatorStatementList;
nonterminal ActPars ActPars;
nonterminal TermList TermList ;
nonterminal  Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal Label Label;
nonterminal PrintStmtWithoutNumber PrintStmtWithoutNumber; 
nonterminal CondFactList CondFactList;
nonterminal ConditionList ConditionList;
nonterminal CondTermList CondTermList;
nonterminal CondFactDecl CondFactDecl;
nonterminal DesignatorList DesignatorList;
nonterminal Declaration Declaration ;
nonterminal VarDeclListing VarDeclListing;
nonterminal OptionalActParsList OptionalActParsList;
nonterminal OptionalActPars OptionalActPars;
nonterminal BreakStmt BreakStmt;
nonterminal ContinueStmt ContinueStmt;
nonterminal ReturnVoidStmt ReturnVoidStmt;
nonterminal ReturnExprStmt ReturnExprStmt;
nonterminal Block Block;
nonterminal ReadStmt ReadStmt;
nonterminal PrintStmtWithNumber PrintStmtWithNumber;
nonterminal ForStmt ForStmt;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, ConstDecl, MethodDecl, FormalParamDecl, MethodTypeName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, ConstValue, MethodDeclType, TermDecl, ExprDecl, Factor;
precedence left  ELSE;


Program ::= (Program) PROG ProgName:p DeclarationsList:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(p, D1, M2); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

DeclarationsList ::=(ManyDeclarationsList) DeclarationsList:D1 Declaration:D2 {: RESULT=new ManyDeclarationsList(D1, D2); RESULT.setLine(D1left); :} 
                   |(NoDeclarationsList) {: RESULT=new NoDeclarationsList(); :} /* epsilon */
                   ;

Declaration ::= ConstDeclList:C1 {: RESULT=new DeclarationDerived1(C1); RESULT.setLine(C1left); :} 
				| VarDeclList:V1 {: RESULT=new DeclarationDerived2(V1); RESULT.setLine(V1left); :}
				;

ConstDeclList ::= CONST Type:T1 ConstDeclarations:C2 SEMI {: RESULT=new ConstDeclListDerived1(T1, C2); RESULT.setLine(T1left); :};

ConstDeclarations ::= ConstDecl:C1 {: RESULT=new ConstDeclarationsDerived1(C1); RESULT.setLine(C1left); :}
                    | ConstDeclarations:C1 COMMA ConstDecl:C2 {: RESULT=new ConstDeclarationsDerived2(C1, C2); RESULT.setLine(C1left); :}
                    ;

ConstDecl ::= (ConstDecl) IDENT:constName EQUAL ConstValue:constKind {: RESULT=new ConstDecl(constName, constKind); RESULT.setLine(constNameleft); :};

ConstValue ::=(ConstValueNumber) NUMBER_CONST:numVal {: RESULT=new ConstValueNumber(numVal); RESULT.setLine(numValleft); :} 
             |(ConstValueCharacter) CHAR_CONST:charVal {: RESULT=new ConstValueCharacter(charVal); RESULT.setLine(charValleft); :} 
             |(ConstValueBoolean) BOOL_CONST:boolVal {: RESULT=new ConstValueBoolean(boolVal); RESULT.setLine(boolValleft); :}
             ;

VarDeclList ::= Type:varDecl VarDeclarations:V1 SEMI {: RESULT=new VarDeclListDerived1(varDecl, V1); RESULT.setLine(varDeclleft); :}
 				|(ErrorSemi) error SEMI:l
              {: parser.report_error("Izvrsen oporavak do ; na liniji " + lleft, null); :} {: RESULT=new ErrorSemi(); :}
             ;

VarDeclListing ::= VarDeclListing:V1 VarDeclList:V2 {: RESULT=new VarDeclListingDerived1(V1, V2); RESULT.setLine(V1left); :} 
				| {: RESULT=new VarDeclListingDerived2(); :} /* epsilon */ 
				;

VarDeclarations ::= VarDecl:V1 {: RESULT=new VarDeclarationsDerived1(V1); RESULT.setLine(V1left); :} 
                  | VarDeclarations:V1 COMMA VarDecl:V2 {: RESULT=new VarDeclarationsDerived2(V1, V2); RESULT.setLine(V1left); :}
    			 ;

VarDecl ::= (VarDeclNameArray) IDENT:varName Brackets:B1 {: RESULT=new VarDeclNameArray(varName, B1); RESULT.setLine(varNameleft); :}
          | (VarDeclName) IDENT:varName {: RESULT=new VarDeclName(varName); RESULT.setLine(varNameleft); :} 
          | (VarDeclNameMatrix) IDENT:varName Brackets:B1 Brackets:B2 {: RESULT=new VarDeclNameMatrix(varName, B1, B2); RESULT.setLine(varNameleft); :}
          |(ErrorComma1) error:l 
              {: parser.report_error("Izvrsen oporavak do ,  na liniji " +lleft, null); :} {: RESULT=new ErrorComma1(); :}
          ;

Brackets ::= LSQUARE RSQUARE {: RESULT=new BracketsDerived1(); :} ;

StaticInitializer ::= STATIC LBRACE StatementList:S1 RBRACE {: RESULT=new StaticInitializerDerived1(S1); RESULT.setLine(S1left); :}; 

MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}
                 | {: RESULT=new MethodDeclListDerived2(); :} /* epsilon */;
                 
MethodDecl ::= (MethodDeclWithFormPars) MethodTypeName:M1 LPAREN FormPars:formalParam RPAREN VarDeclListing:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDeclWithFormPars(M1, formalParam, V2, S3); RESULT.setLine(M1left); :} |
				(MethodDeclWithoutFormPars) MethodTypeName:M1 LPAREN RPAREN VarDeclListing:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDeclWithoutFormPars(M1, V2, S3); RESULT.setLine(M1left); :} 
				;

MethodTypeName ::=(MethodTypeName)  MethodDeclType:M1 IDENT:methodName {: RESULT=new MethodTypeName(M1, methodName); RESULT.setLine(M1left); :};
MethodDeclType ::=(MethodType) Type:t {: RESULT=new MethodType(t); RESULT.setLine(tleft); :} 
                 |(MethodVoid) VOID:t {: RESULT=new MethodVoid(); :}
                 ;

FormPars ::= FormalParamList:F1 {: RESULT=new FormParsDerived1(F1); RESULT.setLine(F1left); :} ;

FormalParamList ::= FormalParamList:F1 COMMA FormalParamDecl:F2 {: RESULT=new FormalParamListDerived1(F1, F2); RESULT.setLine(F1left); :}
                  | FormalParamDecl:F1 {: RESULT=new FormalParamListDerived2(F1); RESULT.setLine(F1left); :}
                   ;

FormalParamDecl ::=(ArrayFormalParam) Type:T1 IDENT:t Brackets:B2 {: RESULT=new ArrayFormalParam(T1, t, B2); RESULT.setLine(T1left); :}
                  |(FormalParam) Type:T1 IDENT:t {: RESULT=new FormalParam(T1, t); RESULT.setLine(T1left); :} 
                  ;



Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};


StatementList ::= StatementList:S1 StatementDecl:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
                | {: RESULT=new StatementListDerived2(); :} /* epsilon */
                ;

StatementDecl ::= IfStmt:I1 {: RESULT=new StatementDeclDerived1(I1); RESULT.setLine(I1left); :}
                | IfElseStmt:I1 {: RESULT=new StatementDeclDerived2(I1); RESULT.setLine(I1left); :}
                | BreakStmt:B1 {: RESULT=new StatementDeclDerived3(B1); RESULT.setLine(B1left); :}
                | ContinueStmt:C1 {: RESULT=new StatementDeclDerived4(C1); RESULT.setLine(C1left); :}
                | ReturnVoidStmt:R1 {: RESULT=new StatementDeclDerived5(R1); RESULT.setLine(R1left); :}
                | ReturnExprStmt:R1 {: RESULT=new StatementDeclDerived6(R1); RESULT.setLine(R1left); :}
                | ReadStmt:R1 {: RESULT=new StatementDeclDerived7(R1); RESULT.setLine(R1left); :}
                | PrintStmtWithNumber:P1 {: RESULT=new StatementDeclDerived8(P1); RESULT.setLine(P1left); :}
                | PrintStmtWithoutNumber:P1 {: RESULT=new StatementDeclDerived9(P1); RESULT.setLine(P1left); :}
                | ForStmt:F1 {: RESULT=new StatementDeclDerived10(F1); RESULT.setLine(F1left); :}
                | Block:B1 {: RESULT=new StatementDeclDerived11(B1); RESULT.setLine(B1left); :}
                | (DesignatorStatementStatementDecl) DesignatorStatementDecl:D1 SEMI {: RESULT=new DesignatorStatementStatementDecl(D1); RESULT.setLine(D1left); :} 
                ;

IfStmt ::=(IfStmt) IF LPAREN ConditionList:C1 RPAREN StatementDecl:S2 {: RESULT=new IfStmt(C1, S2); RESULT.setLine(C1left); :};

IfElseStmt ::=(IfElse) IfStmt:I1 ELSE StatementDecl:S2 {: RESULT=new IfElse(I1, S2); RESULT.setLine(I1left); :};

BreakStmt ::= (BreakStmt)BREAK SEMI {: RESULT=new BreakStmt(); :};
ContinueStmt ::= (ContinueStmt)CONTINUE SEMI {: RESULT=new ContinueStmt(); :};
ReturnVoidStmt ::= (ReturnVoid) RETURN SEMI {: RESULT=new ReturnVoid(); :};
ReturnExprStmt ::= (ReturnExpr) RETURN ExprDecl:t SEMI {: RESULT=new ReturnExpr(t); RESULT.setLine(tleft); :};
ReadStmt ::= (ReadStmt) READ LPAREN Designator:d RPAREN SEMI {: RESULT=new ReadStmt(d); RESULT.setLine(dleft); :};
PrintStmtWithNumber ::=(PrintStmtWithNumber) PRINT LPAREN ExprDecl:t COMMA NUMBER_CONST:width RPAREN SEMI {: RESULT=new PrintStmtWithNumber(t, width); RESULT.setLine(tleft); :};
PrintStmtWithoutNumber ::= (PrintStmtWithoutNumber) PRINT LPAREN ExprDecl:t RPAREN SEMI {: RESULT=new PrintStmtWithoutNumber(t); RESULT.setLine(tleft); :};
ForStmt ::= FOR LPAREN DesignatorStmtList:D1 SEMI CondFactList:C2 SEMI DesignatorStmtList:D3 RPAREN StatementDecl:S4 {: RESULT=new ForStmtDerived1(D1, C2, D3, S4); RESULT.setLine(D1left); :};

Block ::= LBRACE StatementList:S1 RBRACE {: RESULT=new BlockDerived1(S1); RESULT.setLine(S1left); :};

CondFactList ::= ConditionList:C1 {: RESULT=new CondFactListDerived1(C1); RESULT.setLine(C1left); :}
               | {: RESULT=new CondFactListDerived2(); :} /* epsilon */
               ;

ConditionList ::= ConditionList:C1 OR CondTermList:C2 {: RESULT=new ConditionListDerived1(C1, C2); RESULT.setLine(C1left); :}
                | CondTermList:C1 {: RESULT=new ConditionListDerived2(C1); RESULT.setLine(C1left); :}
                ;

CondTermList ::= CondTermList:C1 AND CondFactDecl:C2 {: RESULT=new CondTermListDerived1(C1, C2); RESULT.setLine(C1left); :}
               | CondFactDecl:C1 {: RESULT=new CondTermListDerived2(C1); RESULT.setLine(C1left); :}
               ;

CondFactDecl ::= CondFactDecl:C1 Relop:R2 ExprDecl:E3 {: RESULT=new CondFactDeclDerived1(C1, R2, E3); RESULT.setLine(C1left); :}
               | ExprDecl:E1 {: RESULT=new CondFactDeclDerived2(E1); RESULT.setLine(E1left); :}
               ;

DesignatorStmtList ::= DesignatorStatementList:D1 {: RESULT=new DesignatorStmtListDerived1(D1); RESULT.setLine(D1left); :}
                     | {: RESULT=new DesignatorStmtListDerived2(); :} /* epsilon */
                     ;

DesignatorStatementList ::= DesignatorStatementList:D1 COMMA DesignatorStatementDecl:D2 {: RESULT=new DesignatorStatementListDerived1(D1, D2); RESULT.setLine(D1left); :}
                           | DesignatorStatementDecl:D1 {: RESULT=new DesignatorStatementListDerived2(D1); RESULT.setLine(D1left); :}
                           ;

DesignatorStatementDecl ::=(Assignment) Designator:d Assignop:A1 ExprDecl:e {: RESULT=new Assignment(d, A1, e); RESULT.setLine(dleft); :}
						   |(AssignErr) Designator:D1 Assignop:A2 error {: RESULT=new AssignErr(D1, A2); RESULT.setLine(D1left); :} 
                           |(FunctionCallWithParam) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new FunctionCallWithParam(D1, A2); RESULT.setLine(D1left); :}
                           |(FunctionCallWithoutParam) Designator:D1 LPAREN RPAREN {: RESULT=new FunctionCallWithoutParam(D1); RESULT.setLine(D1left); :}
                           |(Increment) Designator:D1 INC {: RESULT=new Increment(D1); RESULT.setLine(D1left); :}
                           |(Decrement) Designator:D1 DEC {: RESULT=new Decrement(D1); RESULT.setLine(D1left); :}
                           | LSQUARE DesignatorListForStmt:D1 MUL Designator:D2 RSQUARE EQUAL Designator:D3 {: RESULT=new DesignatorStatementDeclDerived1(D1, D2, D3); RESULT.setLine(D1left); :}
                           ;
                           
DesignatorListForStmt ::=(DesignatorListForStmtMore) DesignatorListNotEmpty:D1 {: RESULT=new DesignatorListForStmtMore(D1); RESULT.setLine(D1left); :}
						| (DesignatorListForStmtNone) {: RESULT=new DesignatorListForStmtNone(); :} /* empty */
   						;

DesignatorListNotEmpty ::= (SingleDesignatorList)  Designator:D1 COMMA {: RESULT=new SingleDesignatorList(D1); RESULT.setLine(D1left); :}
    					|(MultipleDesignatorList) DesignatorListNotEmpty:D1  Designator:D2 COMMA {: RESULT=new MultipleDesignatorList(D1, D2); RESULT.setLine(D1left); :}
    					;

ActPars ::= (MultipleParams) ActPars:A1 COMMA ExprDecl:E2 {: RESULT=new MultipleParams(A1, E2); RESULT.setLine(A1left); :}
           |(SingleParam) ExprDecl:E1 {: RESULT=new SingleParam(E1); RESULT.setLine(E1left); :}
           ;

ExprDecl ::=(NegativeTerm) MINUS TermDecl:t {: RESULT=new NegativeTerm(t); RESULT.setLine(tleft); :}
           |(SingleTerm) TermDecl:t {: RESULT=new SingleTerm(t); RESULT.setLine(tleft); :}
           |(AddopExpr) ExprDecl:te Addop:A1 TermDecl:t {: RESULT=new AddopExpr(te, A1, t); RESULT.setLine(teleft); :}
           ;

TermDecl ::=(MulopExpr) TermDecl:T1 Mulop:M2 Factor:t {: RESULT=new MulopExpr(T1, M2, t); RESULT.setLine(T1left); :}
           | (SingleFactor) Factor:t {: RESULT=new SingleFactor(t); RESULT.setLine(tleft); :} 
           ;

Factor ::= (FuncCallWithParam) Designator:d LPAREN ActPars:A1 RPAREN {: RESULT=new FuncCallWithParam(d, A1); RESULT.setLine(dleft); :}
		 |(FuncCallWithoutParam) Designator:d LPAREN RPAREN {: RESULT=new FuncCallWithoutParam(d); RESULT.setLine(dleft); :}
         |(Const) ConstValue:value {: RESULT=new Const(value); RESULT.setLine(valueleft); :}
         |(ArrayCreation) NEW Type:T1 LSQUARE ExprDecl:e RSQUARE {: RESULT=new ArrayCreation(T1, e); RESULT.setLine(T1left); :}
         |(MatrixCreation) NEW Type:T1 LSQUARE ExprDecl:e RSQUARE LSQUARE ExprDecl:e1 RSQUARE {: RESULT=new MatrixCreation(T1, e, e1); RESULT.setLine(T1left); :}
         |(ObjectCreation) NEW Type:T1 LPAREN ActPars:A2 RPAREN {: RESULT=new ObjectCreation(T1, A2); RESULT.setLine(T1left); :}
         |(ExpresionInBrackets) LPAREN ExprDecl:e RPAREN {: RESULT=new ExpresionInBrackets(e); RESULT.setLine(eleft); :}
         |(FactorDesignator) Designator:d {: RESULT=new FactorDesignator(d); RESULT.setLine(dleft); :}
         |(MaxCalc) MAX Designator:d {: RESULT=new MaxCalc(d); RESULT.setLine(dleft); :}
         ;

OptionalActParsList ::= OptionalActPars:O1 {: RESULT=new OptionalActParsListDerived1(O1); RESULT.setLine(O1left); :}
                      | {: RESULT=new OptionalActParsListDerived2(); :} /* epsilon */
                      ;



Designator ::=   (SimpleDesignator) IDENT:name {: RESULT=new SimpleDesignator(name); RESULT.setLine(nameleft); :}
				 |(MultipleFieldAccess) Designator:d DOT IDENT:name {: RESULT=new MultipleFieldAccess(d, name); RESULT.setLine(dleft); :}
                 |(SingleFieldAccess) DOT IDENT:name {: RESULT=new SingleFieldAccess(name); RESULT.setLine(nameleft); :}
                 |(ArrayIndexing)Designator:d LSQUARE ExprDecl:index RSQUARE {: RESULT=new ArrayIndexing(d, index); RESULT.setLine(dleft); :}
                 ;



Assignop ::= EQUAL {: RESULT=new AssignopDerived1(); :};

Label ::= IDENT:I1 {: RESULT=new LabelDerived1(I1); RESULT.setLine(I1left); :};

Relop ::= EQUALTO {: RESULT=new RelopDerived1(); :}
        | NOTEQUALTO {: RESULT=new RelopDerived2(); :}
        | GREATER {: RESULT=new RelopDerived3(); :}
        | GEQUAL {: RESULT=new RelopDerived4(); :}
        | LESSER {: RESULT=new RelopDerived5(); :}
        | LEQUAL {: RESULT=new RelopDerived6(); :};

Addop ::=(AddopPlus) PLUS {: RESULT=new AddopPlus(); :}
        |(AddopMinus) MINUS {: RESULT=new AddopMinus(); :};

Mulop ::= (MulopMul) MUL {: RESULT=new MulopMul(); :}
        | (MulopDiv) DIV {: RESULT=new MulopDiv(); :}
        | (MulopMov) MOV {: RESULT=new MulopMov(); :};