package rs.ac.bg.etf.pp1;



import rs.ac.bg.etf.pp1.CounterVisitor.FormParamCounter;
import rs.ac.bg.etf.pp1.CounterVisitor.VarDeclarationCounter;
import rs.ac.bg.etf.pp1.ast.AddopExpr;
import rs.ac.bg.etf.pp1.ast.AddopMinus;
import rs.ac.bg.etf.pp1.ast.AddopPlus;
import rs.ac.bg.etf.pp1.ast.ArrayCreation;
import rs.ac.bg.etf.pp1.ast.ArrayIndexing;
import rs.ac.bg.etf.pp1.ast.Assignment;
import rs.ac.bg.etf.pp1.ast.Const;
import rs.ac.bg.etf.pp1.ast.ConstValueBoolean;
import rs.ac.bg.etf.pp1.ast.ConstValueCharacter;
import rs.ac.bg.etf.pp1.ast.ConstValueNumber;
import rs.ac.bg.etf.pp1.ast.Decrement;
import rs.ac.bg.etf.pp1.ast.FactorDesignator;
import rs.ac.bg.etf.pp1.ast.Increment;
import rs.ac.bg.etf.pp1.ast.MatrixCreation;
import rs.ac.bg.etf.pp1.ast.MaxCalc;
import rs.ac.bg.etf.pp1.ast.MethodDeclWithFormPars;
import rs.ac.bg.etf.pp1.ast.MethodDeclWithoutFormPars;
import rs.ac.bg.etf.pp1.ast.MethodTypeName;
import rs.ac.bg.etf.pp1.ast.MulopDiv;
import rs.ac.bg.etf.pp1.ast.MulopExpr;
import rs.ac.bg.etf.pp1.ast.MulopMov;
import rs.ac.bg.etf.pp1.ast.MulopMul;
import rs.ac.bg.etf.pp1.ast.NegativeTerm;
import rs.ac.bg.etf.pp1.ast.PrintStmtWithNumber;
import rs.ac.bg.etf.pp1.ast.PrintStmtWithoutNumber;
import rs.ac.bg.etf.pp1.ast.ReadStmt;
import rs.ac.bg.etf.pp1.ast.SimpleDesignator;
import rs.ac.bg.etf.pp1.ast.SyntaxNode;
import rs.ac.bg.etf.pp1.ast.VisitorAdaptor;
import rs.etf.pp1.mj.runtime.Code;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class CodeGenerator extends VisitorAdaptor {
	
	private int mainPc;
	
	public int getMainPc() {
		return mainPc;
	}
	
	// printStatement print(expr) and print(expr,num);
	
	public void visit(PrintStmtWithoutNumber printStmt) {
		
		if(printStmt.getExprDecl().struct == Tab.intType || printStmt.getExprDecl().struct== Tab.boolType) {
			Code.loadConst(5);
			Code.put(Code.print);
		}else {
			Code.loadConst(1);
			Code.put(Code.bprint);
		}
	
	}
	
	public void visit(PrintStmtWithNumber statementPrintWithWidth) {
		
		Code.loadConst(statementPrintWithWidth.getWidth());			
		if(statementPrintWithWidth.getExprDecl().struct == Tab.intType || statementPrintWithWidth.getExprDecl().struct== Tab.boolType) {
			Code.put(Code.print);
		} else {
			Code.put(Code.bprint);
		}		
	}
	
	public void visit(Const cnst) {
		Obj con = Tab.insert(Obj.Con, "$", cnst.struct);
		con.setLevel(0);

		if(cnst.getConstValue() instanceof ConstValueNumber  ) {
			 ConstValueNumber numValue = (ConstValueNumber) cnst.getConstValue();
		        con.setAdr(numValue.getNumVal()); 
		}
		else if(cnst.getConstValue() instanceof ConstValueBoolean) {
			 ConstValueBoolean boolValue = (ConstValueBoolean) cnst.getConstValue();
		        con.setAdr(boolValue.getBoolVal() ? 1 : 0);
		}
		else if (cnst.getConstValue() instanceof ConstValueCharacter){
			ConstValueCharacter charValue = (ConstValueCharacter) cnst.getConstValue();
	        con.setAdr(charValue.getCharVal()); 
		}
		
		Code.load(con);
	}
	
	public void visit(MethodTypeName methodTypeName) {
		
		if("main".equalsIgnoreCase(methodTypeName.getMethodName())){
			mainPc = Code.pc;
		}
		methodTypeName.obj.setAdr(Code.pc); //stavljamo PC 
		
		//Dohvatanje argumenata i lokalnih promenljivih
		SyntaxNode methodNode = methodTypeName.getParent();
		VarDeclarationCounter varCnt = new VarDeclarationCounter();
		methodNode.traverseBottomUp(varCnt);
		FormParamCounter fpCnt = new FormParamCounter();
		methodNode.traverseBottomUp(fpCnt);
		Code.put(Code.enter);
		Code.put(fpCnt.getCount());
		Code.put(varCnt.getCount()+fpCnt.getCount());
	}
	
	public void visit(MethodDeclWithFormPars methodDecl) {
		
		Code.put(Code.exit);
		Code.put(Code.return_);
	}
	
	public void visit(MethodDeclWithoutFormPars methodDecl) {
		
		Code.put(Code.exit);
		Code.put(Code.return_);
	}
	
	public void visit(Assignment assignment) {

		Code.store(assignment.getDesignator().obj);
		
		
	}
	
	
	
	public void visit(SimpleDesignator simpleDesign) {
		SyntaxNode parent = simpleDesign.getParent();
		//msm da treba da bude od Factor opcije
		if(parent.getClass() == ArrayIndexing.class && simpleDesign.obj.getType().getElemType().getKind()== Struct.Array) {
			Code.load(simpleDesign.obj);
			Code.put(Code.dup);
			return;
		}
		if(Assignment.class != parent.getClass() && ReadStmt.class != parent.getClass() && Increment.class != parent.getClass() && Decrement.class != parent.getClass()) {
			Code.load(simpleDesign.obj);
		}
	}

	
	boolean isMatrix= false;
	public void visit(ArrayIndexing singleArray) {
		SyntaxNode parent = singleArray.getParent();

		// 2d inner
		if (parent.getClass() == ArrayIndexing.class) {
			isMatrix = true;
			return;
		}

		//2d outer
		if (isMatrix) {
			Code.put(Code.dup_x2); //adrMat col row col 2 3 2 4 3 pop
			Code.put(Code.pop);
			Code.put(Code.dup_x1);
			Code.put(Code.pop); //  col row 2 3 4 //col row adrMat
			Code.loadConst(0); //adrMat col row adrMat 0
			Code.put(Code.aload); //adrMat col row colCount
			Code.put(Code.mul);//adrMat col row*colCount
			Code.put(Code.add);//adrMat col+ row*colCount
			Code.loadConst(1);// adrMat col+row*colCOunt+1
			Code.put(Code.add); //adrMat 3
			if(parent.getClass() != FactorDesignator.class) {
			isMatrix = false;
			}
		}

		//1d i 2d outer
		if (Assignment.class != parent.getClass() && ArrayIndexing.class != parent.getClass() &&  ReadStmt.class != parent.getClass() &&  Increment.class != parent.getClass() && Decrement.class != parent.getClass()) {
			Code.load(singleArray.obj); 
		}
	}

	
	public void visit(Increment designatorInc) {
		if(designatorInc.getDesignator().obj.getKind() == Obj.Var) {
			Code.load(designatorInc.getDesignator().obj);
		}
		else if(designatorInc.getDesignator().obj.getKind() == Obj.Elem) {
			Code.put(Code.dup2);
			Code.load(designatorInc.getDesignator().obj);
		}
		Code.loadConst(1);
		Code.put(Code.add);
		Code.store(designatorInc.getDesignator().obj);
	}
	
	public void visit(Decrement designatorDec) {
		if(designatorDec.getDesignator().obj.getKind() == Obj.Var) {
			Code.load(designatorDec.getDesignator().obj);
		}
		else if(designatorDec.getDesignator().obj.getKind() == Obj.Elem) {
			Code.put(Code.dup2);
			Code.load(designatorDec.getDesignator().obj);
		}
		Code.loadConst(1);
		Code.put(Code.sub);
		Code.store(designatorDec.getDesignator().obj);
	}
	
	public void visit(ReadStmt readStatement) {
	    Struct type = readStatement.getDesignator().obj.getType();
	  
	    if(type == Tab.intType || type == Tab.boolType) {
	    	Code.put(Code.read);            
	    } else if( type == Tab.charType){
	     
	        Code.put(Code.bread);
	    }


	  
	    Code.store(readStatement.getDesignator().obj);
	}
	
	public void visit(NegativeTerm minusTerm) {
		Code.put(Code.neg);
	}
	
	public void visit(AddopExpr opExpr) {
		if(opExpr.getAddop() instanceof AddopPlus) {
			Code.put(Code.add);
		}
		else if(opExpr.getAddop() instanceof AddopMinus) {
			Code.put(Code.sub);
		}
	}
	
	public void visit(MulopExpr opExpr) {
		if(opExpr.getMulop() instanceof MulopMul ) {
			Code.put(Code.mul);
		}
		else if(opExpr.getMulop() instanceof MulopDiv) {
			Code.put(Code.div);
		}
		else if(opExpr.getMulop() instanceof MulopMov) {
			Code.put(Code.rem);
		}
	}
	
	public void visit(ArrayCreation array) {
		Code.put(Code.newarray); 
		if(array.struct.getElemType() == Tab.charType) {
			Code.put(0);
		}
		else {
			Code.put(1);
		}
	}
	public void visit(MatrixCreation matrix) {
	  
	    Code.put(Code.dup_x1);
	    Code.put(Code.mul);  
	    Code.loadConst(1); 
	    Code.put(Code.add);  
	    Code.put(Code.newarray);
	    if (matrix.struct.getElemType() == Tab.charType) {
	        Code.put(0); 
	    } else {
	        Code.put(1); 
	    }
	    Code.put(Code.dup);
	    Code.put(Code.dup_x2);
	    Code.put(Code.pop);
	    Code.put(Code.dup_x1);
	    Code.put(Code.pop);
	    Code.loadConst(0); 
	    Code.put(Code.dup_x1);
	    Code.put(Code.pop);
	    Code.put(Code.astore);    
	}
	
	public void visit(MaxCalc matrix) {

	    Code.loadConst(1);  
	    Code.put(Code.aload);  
	    Code.loadConst(2);// arr[1] 2 
	    //2 arr[1] 2
	    
	    
	    // Label for the start of the loop
	    int loopStart = Code.pc;
	    Code.put(Code.dup_x1); //2 arr[1] 2 
	    Code.put(Code.dup); // 2 0 2 2
	    Code.load(matrix.getDesignator().obj); //2 arr[1] 2 2 arr 0
	    Code.loadConst(0);//2  arr[1] 2 2 arr[0]
	    Code.put(Code.aload);
	    Code.put(Code.arraylength); //22 arr[1] 2 2 7
	    // Compare index with array size (i <= size)
//	    Code.put(Code.dup_x1); // arr[1] 2  2 7 
	    Code.putFalseJump(Code.le, 0); // if i > size, exit loop EXIT LOOP
	    int loopExit = Code.pc - 2;
	    
	    // Load the element at the current index (array[i])
	    Code.load(matrix.getDesignator().obj); //2 arr[1] 2 arr
	    Code.put(Code.dup_x1); //2 arr[1] arr 2 arr
	    Code.put(Code.pop); // 2 arr[1] arr 2
	    Code.put(Code.aload); //2 arr[1] arr[2]
	    
	    // Compare with current max
	    Code.put(Code.dup2); //2 arr[1] arr[2] arr[1] arr[2] 
	    Code.putFalseJump(Code.gt, 0); // if value <= max, skip update
	    int skipUpdate = Code.pc - 2;
	    // jmp jgt -- POCETSAK LOOP
	    //2 arr[1] arr[2]
	    Code.put(Code.dup_x1); // 2 arr[2] arr[1] arr[2]
	    Code.put(Code.pop);
	    Code.put(Code.pop); // 2 arr[2]
	    Code.fixup(skipUpdate);
	    Code.put(Code.dup_x1); // arr[2] 2 arr[2]
	    Code.put(Code.pop); // arr[2] 2 
	    // Increment index (i++)
	    Code.loadConst(1);
	    Code.put(Code.add); //arr[2] 3
	    
	    // Jump to the start of the loop
	    Code.putJump(loopStart);
	    
	    // Label for exiting the loop
	    Code.fixup(loopExit);
	    
	}

	

}


//
// u expr je vec stavljena vrednost na stek!


// [2][3] 2 3 dup x1
// 3 2 3 mul addConst(1)
// 3 6 1 add
// 3 7 new array 
// 3 adrArray dup
// 3 adrArray adrArray dup_x2 
// adrArray 3 adrArray adrArray  pop
// adrArray 3 adrArray dup_x1
// adrArray adrArray 3 adrArray pop
// adrArray adrArray 3 
// adrArray adrArray 3 addConst(0)
// adrArray adrArray 3 0  dup x1
// adrArray 0 3 0 pop
// adrArray 0 3 astore
// putstatic(0)

